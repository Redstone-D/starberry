//! Resource locator module
//! Generated by build.rs - DO NOT EDIT MANUALLY

use std::path::{Path, PathBuf};

/// Locate a resource file or directory from any execution context
pub fn locate_resource(resource_path: &str) -> Option<PathBuf> {
    let resource = Path::new(resource_path);
    
    // Strategy 1: Check current directory
    if resource.exists() {
        return Some(resource.to_path_buf());
    }
    
    // Strategy 2: Check relative to executable
    if let Ok(exe_path) = std::env::current_exe() {
        if let Some(exe_dir) = exe_path.parent() {
            let exe_relative = exe_dir.join(resource_path);
            if exe_relative.exists() {
                return Some(exe_relative);
            }
        }
    }
    
    // Strategy 3: Check workspace root (if applicable)
    if true {
        if let Some(workspace_root) = find_workspace_root() {
            let workspace_relative = workspace_root.join(resource_path);
            if workspace_relative.exists() {
                return Some(workspace_relative);
            }
        }
    }
    
    None
}

/// Find the workspace root directory
fn find_workspace_root() -> Option<PathBuf> {
    let mut current = std::env::current_dir().ok()?;
    
    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            if let Ok(content) = std::fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    return Some(current);
                }
            }
        }
        
        if !current.pop() {
            break;
        }
    }
    
    None
}
