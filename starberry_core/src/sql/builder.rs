use super::connection::DbConnection;
use super::error::DbError;
use super::query::QueryResult;
use super::encode::Encode;
use super::row::FromRow;
use std::collections::HashMap;

/// Builder for SQL queries, generated by the `sql!` macro.
pub struct SqlQuery<'q> {
    sql: &'q str,
    params: Vec<String>,
}

impl<'q> SqlQuery<'q> {
    /// Create a new SQL query builder.
    pub fn new(sql: &'q str) -> Self {
        Self { sql, params: Vec::new() }
    }

    /// Bind a parameter to the query.
    pub fn bind<T: Encode>(mut self, value: T) -> Self {
        let encoded = value.encode().unwrap();
        self.params.push(encoded);
        self
    }

    /// Execute the query and return all rows as raw maps.
    pub async fn fetch_all(self, conn: &mut DbConnection) -> Result<Vec<HashMap<String, String>>, DbError> {
        match conn.execute_query(self.sql, self.params).await? {
            QueryResult::Rows(rows) => Ok(rows),
            QueryResult::Count(_) | QueryResult::Empty => Ok(Vec::new()),
            QueryResult::Error(e) => Err(e),
        }
    }

    /// Execute the query and return the first row as a raw map.
    pub async fn fetch_one(self, conn: &mut DbConnection) -> Result<HashMap<String, String>, DbError> {
        let rows = self.fetch_all(conn).await?;
        rows.into_iter().next().ok_or_else(|| DbError::QueryError("Expected one row".into()))
    }

    /// Execute the query and map all rows into the specified type.
    pub async fn fetch_all_as<T: FromRow>(self, conn: &mut DbConnection) -> Result<Vec<T>, DbError> {
        let rows = self.fetch_all(conn).await?;
        rows.into_iter().map(|row| T::from_row(&row)).collect()
    }

    /// Execute the query and map the first row into the specified type.
    pub async fn fetch_one_as<T: FromRow>(self, conn: &mut DbConnection) -> Result<T, DbError> {
        let row = self.fetch_one(conn).await?;
        T::from_row(&row)
    }

    /// Execute the query as a command, returning the affected row count.
    pub async fn execute(self, conn: &mut DbConnection) -> Result<usize, DbError> {
        match conn.execute_query(self.sql, self.params).await? {
            QueryResult::Count(n) => Ok(n),
            _ => Ok(0),
        }
    }
} 